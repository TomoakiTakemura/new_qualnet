/// \file phy_dot11ac.cpp
///
/// \brief Phy 802.11ac implementation
///
/// This file contains the implementation of 802.11ac PHY APIs

// Copyright (c) 2001-2015, SCALABLE Network Technologies, Inc.  All Rights Reserved.
//                          600 Corporate Pointe
//                          Suite 1200
//                          Culver City, CA 90230
//                          info@scalable-networks.com
//
// This source code is licensed, not sold, and is subject to a written
// license agreement.  Among other things, no portion of this source
// code may be copied, transmitted, disclosed, displayed, distributed,
// translated, used as the basis for a derivative work, or used, in
// whole or in part, for any program or purpose other than its intended
// use in compliance with the license agreement as part of the QualNet
// software.  This source code and certain of the algorithms contained
// within it are confidential trade secrets of Scalable Network
// Technologies, Inc. and may not be used as the basis for any other
// software, hardware, product or service.

#include <iostream>
#include <sstream>

#include <math.h>

#include "api.h"
#include "partition.h"
#include "dynamic.h"
#include "phy.h"
#include "antenna.h"
#include "antenna_switched.h"
#include "antenna_steerable.h"
#include "antenna_patterned.h"
#include "interference.h"
#include "phy_802_11.h"

#include "phy_dot11ac.h"
#include "mimo-mapper.h"

#define DEBUG 0

using namespace Dot11;
using namespace Qos;

const double Phy802_11ac::m_minSensitivity_dBm[NUM_CH_BW_802_11AC] [MCS_NUMS_SINGLE_SS] =
    {
      { -82.0, -79.0, -77.0, -74.0, -70.0, -66.0, -65.0, -64.0, -59.0, -57.0 },
      { -79.0, -76.0, -74.0, -71.0, -67.0, -63.0, -62.0, -61.0, -56.0, -54.0 },
      { -76.0, -73.0, -71.0, -68.0, -64.0, -60.0, -59.0, -58.0, -53.0, -51.0 },
      { -73.0, -70.0, -68.0, -65.0, -61.0, -57.0, -56.0, -55.0, -50.0, -48.0 }
    };


const double Phy802_11ac::m_energyThreshold_dBm[NUM_CH_BW_802_11AC -1] = {-62, -59, -56};

const Phy802_11ac::MCSParam
  Phy802_11ac::MCS_Params[NUM_CH_BW_802_11AC][Phy802_11ac::Max_EQM_MCS] =
    { { { 1, CODERATE_1_2, BPSK, 26, 1, { TYPES_ToUInt64(6500000), TYPES_ToUInt64(7200000) } },
        { 1, CODERATE_1_2, QPSK, 52, 1, { TYPES_ToUInt64(13000000), TYPES_ToUInt64(14400000) } },
        { 1, CODERATE_3_4, QPSK, 78, 1, { TYPES_ToUInt64(19500000), TYPES_ToUInt64(21700000) } },
        { 1, CODERATE_1_2, QAM16, 104, 1, { TYPES_ToUInt64(26000000), TYPES_ToUInt64(28900000) } },
        { 1, CODERATE_3_4, QAM16, 156, 1, { TYPES_ToUInt64(39000000), TYPES_ToUInt64(43300000) } },
        { 1, CODERATE_2_3, QAM64, 208, 1, { TYPES_ToUInt64(52000000), TYPES_ToUInt64(57800000) } },
        { 1, CODERATE_3_4, QAM64, 234, 1, { TYPES_ToUInt64(58500000), TYPES_ToUInt64(65000000) } },
        { 1, CODERATE_5_6, QAM64, 260, 1, { TYPES_ToUInt64(65000000), TYPES_ToUInt64(72200000) } },
        { 1, CODERATE_3_4, QAM256, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },
        { 1, CODERATE_3_4, QAM256, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },

        { 2, CODERATE_1_2, BPSK, 52, 1, { TYPES_ToUInt64(13000000), TYPES_ToUInt64(14400000) } },
        { 2, CODERATE_1_2, QPSK, 104, 1, { TYPES_ToUInt64(26000000), TYPES_ToUInt64(28900000) } },
        { 2, CODERATE_3_4, QPSK, 156, 1, { TYPES_ToUInt64(39000000), TYPES_ToUInt64(43300000) } },
        { 2, CODERATE_1_2, QAM16, 208, 1, { TYPES_ToUInt64(52000000), TYPES_ToUInt64(57800000) } },
        { 2, CODERATE_3_4, QAM16, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },
        { 2, CODERATE_2_3, QAM64, 416, 1, { TYPES_ToUInt64(104000000), TYPES_ToUInt64(115600000) } },
        { 2, CODERATE_3_4, QAM64, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 2, CODERATE_5_6, QAM64, 520, 1, { TYPES_ToUInt64(130000000), TYPES_ToUInt64(144400000) } },
        { 2, CODERATE_3_4, QAM256, 624, 1, { TYPES_ToUInt64(156000000), TYPES_ToUInt64(173300000) } },
        { 2, CODERATE_3_4, QAM256, 624, 1, { TYPES_ToUInt64(156000000), TYPES_ToUInt64(173300000) } },

        { 3, CODERATE_1_2, BPSK, 78, 1, { TYPES_ToUInt64(19500000), TYPES_ToUInt64(21700000) } },
        { 3, CODERATE_1_2, QPSK, 156, 1, { TYPES_ToUInt64(39000000), TYPES_ToUInt64(43300000) } },
        { 3, CODERATE_3_4, QPSK, 234, 1, { TYPES_ToUInt64(58500000), TYPES_ToUInt64(65000000) } },
        { 3, CODERATE_1_2, QAM16, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },
        { 3, CODERATE_3_4, QAM16, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 3, CODERATE_2_3, QAM64, 624, 1, { TYPES_ToUInt64(156000000), TYPES_ToUInt64(173300000) } },
        { 3, CODERATE_3_4, QAM64, 702, 1, { TYPES_ToUInt64(175500000), TYPES_ToUInt64(195000000) } },
        { 3, CODERATE_5_6, QAM64, 780, 1, { TYPES_ToUInt64(195000000), TYPES_ToUInt64(216700000) } },
        { 3, CODERATE_3_4, QAM256, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 3, CODERATE_5_6, QAM256, 1040, 1, { TYPES_ToUInt64(260000000), TYPES_ToUInt64(288900000) } },

        { 4, CODERATE_1_2, BPSK, 104, 1, { TYPES_ToUInt64(26000000), TYPES_ToUInt64(28900000) } },
        { 4, CODERATE_1_2, QPSK, 208, 1, { TYPES_ToUInt64(52000000), TYPES_ToUInt64(57800000) } },
        { 4, CODERATE_3_4, QPSK, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },
        { 4, CODERATE_1_2, QAM16, 416, 1, { TYPES_ToUInt64(104000000), TYPES_ToUInt64(115600000) } },
        { 4, CODERATE_3_4, QAM16, 624, 1, { TYPES_ToUInt64(156000000), TYPES_ToUInt64(173300000) } },
        { 4, CODERATE_2_3, QAM64, 832, 1, { TYPES_ToUInt64(208000000), TYPES_ToUInt64(231100000) } },
        { 4, CODERATE_3_4, QAM64, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 4, CODERATE_5_6, QAM64, 1040, 1, { TYPES_ToUInt64(260000000), TYPES_ToUInt64(288900000) } },
        { 4, CODERATE_3_4, QAM256, 1248, 1, { TYPES_ToUInt64(312000000), TYPES_ToUInt64(346700000) } },
        { 4, CODERATE_3_4, QAM256, 1248, 1, { TYPES_ToUInt64(312000000), TYPES_ToUInt64(346700000) } },

        { 5, CODERATE_1_2, BPSK, 130, 1, { TYPES_ToUInt64(32500000), TYPES_ToUInt64(36100000) } },
        { 5, CODERATE_1_2, QPSK, 260, 1, { TYPES_ToUInt64(65000000), TYPES_ToUInt64(72200000) } },
        { 5, CODERATE_3_4, QPSK, 390, 1, { TYPES_ToUInt64(97500000), TYPES_ToUInt64(108300000) } },
        { 5, CODERATE_1_2, QAM16, 520, 1, { TYPES_ToUInt64(130000000), TYPES_ToUInt64(144400000) } },
        { 5, CODERATE_3_4, QAM16, 780, 1, { TYPES_ToUInt64(195000000), TYPES_ToUInt64(216700000) } },
        { 5, CODERATE_2_3, QAM64, 1040, 1, { TYPES_ToUInt64(260000000), TYPES_ToUInt64(288900000) } },
        { 5, CODERATE_3_4, QAM64, 1170, 1, { TYPES_ToUInt64(292500000), TYPES_ToUInt64(325000000) } },
        { 5, CODERATE_5_6, QAM64, 1300, 1, { TYPES_ToUInt64(325000000), TYPES_ToUInt64(361100000) } },
        { 5, CODERATE_3_4, QAM256, 1560, 1, { TYPES_ToUInt64(390000000), TYPES_ToUInt64(433300000) } },
        { 5, CODERATE_3_4, QAM256, 1560, 1, { TYPES_ToUInt64(390000000), TYPES_ToUInt64(433300000) } },

        { 6, CODERATE_1_2, BPSK, 156, 1, { TYPES_ToUInt64(39000000), TYPES_ToUInt64(43300000) } },
        { 6, CODERATE_1_2, QPSK, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },
        { 6, CODERATE_3_4, QPSK, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 6, CODERATE_1_2, QAM16, 624, 1, { TYPES_ToUInt64(156000000), TYPES_ToUInt64(173300000) } },
        { 6, CODERATE_3_4, QAM16, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 6, CODERATE_2_3, QAM64, 1248, 1, { TYPES_ToUInt64(312000000), TYPES_ToUInt64(346700000) } },
        { 6, CODERATE_3_4, QAM64, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 6, CODERATE_5_6, QAM64, 1560, 1, { TYPES_ToUInt64(390000000), TYPES_ToUInt64(433300000) } },
        { 6, CODERATE_3_4, QAM256, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 6, CODERATE_5_6, QAM256, 2080, 1, { TYPES_ToUInt64(520000000), TYPES_ToUInt64(577800000) } },

        { 7, CODERATE_1_2, BPSK, 182, 1, { TYPES_ToUInt64(45500000), TYPES_ToUInt64(50600000) } },
        { 7, CODERATE_1_2, QPSK, 364, 1, { TYPES_ToUInt64(91000000), TYPES_ToUInt64(101100000) } },
        { 7, CODERATE_3_4, QPSK, 546, 1, { TYPES_ToUInt64(136500000), TYPES_ToUInt64(151700000) } },
        { 7, CODERATE_1_2, QAM16, 728, 1, { TYPES_ToUInt64(182000000), TYPES_ToUInt64(202200000) } },
        { 7, CODERATE_3_4, QAM16, 1092, 1, { TYPES_ToUInt64(273000000), TYPES_ToUInt64(303300000) } },
        { 7, CODERATE_2_3, QAM64, 1456, 1, { TYPES_ToUInt64(364000000), TYPES_ToUInt64(404400000) } },
        { 7, CODERATE_3_4, QAM64, 1638, 1, { TYPES_ToUInt64(409500000), TYPES_ToUInt64(455000000) } },
        { 7, CODERATE_5_6, QAM64, 1820, 1, { TYPES_ToUInt64(455000000), TYPES_ToUInt64(505600000) } },
        { 7, CODERATE_3_4, QAM256, 2184, 2, { TYPES_ToUInt64(546000000), TYPES_ToUInt64(606700000) } },
        { 7, CODERATE_3_4, QAM256, 2184, 2, { TYPES_ToUInt64(546000000), TYPES_ToUInt64(606700000) } },

        { 8, CODERATE_1_2, BPSK, 208, 1, { TYPES_ToUInt64(52000000), TYPES_ToUInt64(57800000) } },
        { 8, CODERATE_1_2, QPSK, 416, 1, { TYPES_ToUInt64(104000000), TYPES_ToUInt64(115600000) } },
        { 8, CODERATE_3_4, QPSK, 624, 1, { TYPES_ToUInt64(156000000), TYPES_ToUInt64(173300000) } },
        { 8, CODERATE_1_2, QAM16, 832, 1, { TYPES_ToUInt64(208000000), TYPES_ToUInt64(231100000) } },
        { 8, CODERATE_3_4, QAM16, 1248, 1, { TYPES_ToUInt64(312000000), TYPES_ToUInt64(346700000) } },
        { 8, CODERATE_2_3, QAM64, 1664, 1, { TYPES_ToUInt64(416000000), TYPES_ToUInt64(462200000) } },
        { 8, CODERATE_3_4, QAM64, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 8, CODERATE_5_6, QAM64, 2080, 1, { TYPES_ToUInt64(520000000), TYPES_ToUInt64(577800000) } },
        { 8, CODERATE_3_4, QAM256, 2496, 2, { TYPES_ToUInt64(624000000), TYPES_ToUInt64(693300000) } },
        { 8, CODERATE_3_4, QAM256, 2496, 2, { TYPES_ToUInt64(624000000), TYPES_ToUInt64(693300000) } } },


      { { 1, CODERATE_1_2, BPSK, 54, 1, { TYPES_ToUInt64(13500000), TYPES_ToUInt64(15000000) } },
        { 1, CODERATE_1_2, QPSK, 108, 1, { TYPES_ToUInt64(27000000), TYPES_ToUInt64(30000000) } },
        { 1, CODERATE_3_4, QPSK, 162, 1, { TYPES_ToUInt64(40500000), TYPES_ToUInt64(45000000) } },
        { 1, CODERATE_1_2, QAM16, 216, 1, { TYPES_ToUInt64(54000000), TYPES_ToUInt64(60000000) } },
        { 1, CODERATE_3_4, QAM16, 324, 1, { TYPES_ToUInt64(81000000), TYPES_ToUInt64(90000000) } },
        { 1, CODERATE_2_3, QAM64, 432, 1, { TYPES_ToUInt64(108000000), TYPES_ToUInt64(120000000) } },
        { 1, CODERATE_3_4, QAM64, 486, 1, { TYPES_ToUInt64(121500000), TYPES_ToUInt64(135000000) } },
        { 1, CODERATE_5_6, QAM64, 540, 1, { TYPES_ToUInt64(135000000), TYPES_ToUInt64(150000000) } },
        { 1, CODERATE_3_4, QAM256, 648, 1, { TYPES_ToUInt64(162000000), TYPES_ToUInt64(180000000) } },
        { 1, CODERATE_5_6, QAM256, 720, 1, { TYPES_ToUInt64(180000000), TYPES_ToUInt64(200000000) } },

        { 2, CODERATE_1_2, BPSK, 108, 1, { TYPES_ToUInt64(27000000), TYPES_ToUInt64(30000000) } },
        { 2, CODERATE_1_2, QPSK, 216, 1, { TYPES_ToUInt64(54000000), TYPES_ToUInt64(60000000) } },
        { 2, CODERATE_3_4, QPSK, 324, 1, { TYPES_ToUInt64(81000000), TYPES_ToUInt64(90000000) } },
        { 2, CODERATE_1_2, QAM16, 432, 1, { TYPES_ToUInt64(108000000), TYPES_ToUInt64(120000000) } },
        { 2, CODERATE_3_4, QAM16, 648, 1, { TYPES_ToUInt64(162000000), TYPES_ToUInt64(180000000) } },
        { 2, CODERATE_2_3, QAM64, 864, 1, { TYPES_ToUInt64(216000000), TYPES_ToUInt64(240000000) } },
        { 2, CODERATE_3_4, QAM64, 972, 1, { TYPES_ToUInt64(243000000), TYPES_ToUInt64(270000000) } },
        { 2, CODERATE_5_6, QAM64, 1080, 1, { TYPES_ToUInt64(270000000), TYPES_ToUInt64(300000000) } },
        { 2, CODERATE_3_4, QAM256, 1296, 1, { TYPES_ToUInt64(324000000), TYPES_ToUInt64(360000000) } },
        { 2, CODERATE_5_6, QAM256, 1440, 1, { TYPES_ToUInt64(360000000), TYPES_ToUInt64(400000000) } },

        { 3, CODERATE_1_2, BPSK, 162, 1, { TYPES_ToUInt64(40500000), TYPES_ToUInt64(45000000) } },
        { 3, CODERATE_1_2, QPSK, 324, 1, { TYPES_ToUInt64(81000000), TYPES_ToUInt64(90000000) } },
        { 3, CODERATE_3_4, QPSK, 486, 1, { TYPES_ToUInt64(121500000), TYPES_ToUInt64(135000000) } },
        { 3, CODERATE_1_2, QAM16, 648, 1, { TYPES_ToUInt64(162000000), TYPES_ToUInt64(180000000) } },
        { 3, CODERATE_3_4, QAM16, 972, 1, { TYPES_ToUInt64(243000000), TYPES_ToUInt64(270000000) } },
        { 3, CODERATE_2_3, QAM64, 1296, 1, { TYPES_ToUInt64(324000000), TYPES_ToUInt64(360000000) } },
        { 3, CODERATE_3_4, QAM64, 1458, 1, { TYPES_ToUInt64(364500000), TYPES_ToUInt64(405000000) } },
        { 3, CODERATE_5_6, QAM64, 1620, 1, { TYPES_ToUInt64(405000000), TYPES_ToUInt64(450000000) } },
        { 3, CODERATE_3_4, QAM256, 1944, 1, { TYPES_ToUInt64(486000000), TYPES_ToUInt64(540000000) } },
        { 3, CODERATE_5_6, QAM256, 2160, 1, { TYPES_ToUInt64(540000000), TYPES_ToUInt64(600000000) } },

        { 4, CODERATE_1_2, BPSK, 216, 1, { TYPES_ToUInt64(54000000), TYPES_ToUInt64(60000000) } },
        { 4, CODERATE_1_2, QPSK, 432, 1, { TYPES_ToUInt64(108000000), TYPES_ToUInt64(120000000) } },
        { 4, CODERATE_3_4, QPSK, 648, 1, { TYPES_ToUInt64(162000000), TYPES_ToUInt64(180000000) } },
        { 4, CODERATE_1_2, QAM16, 864, 1, { TYPES_ToUInt64(216000000), TYPES_ToUInt64(240000000) } },
        { 4, CODERATE_3_4, QAM16, 1296, 1, { TYPES_ToUInt64(324000000), TYPES_ToUInt64(360000000) } },
        { 4, CODERATE_2_3, QAM64, 1728, 1, { TYPES_ToUInt64(432000000), TYPES_ToUInt64(480000000) } },
        { 4, CODERATE_3_4, QAM64, 1944, 1, { TYPES_ToUInt64(486000000), TYPES_ToUInt64(540000000) } },
        { 4, CODERATE_5_6, QAM64, 2160, 1, { TYPES_ToUInt64(540000000), TYPES_ToUInt64(600000000) } },
        { 4, CODERATE_3_4, QAM256, 2592, 2, { TYPES_ToUInt64(648000000), TYPES_ToUInt64(720000000) } },
        { 4, CODERATE_5_6, QAM256, 2880, 2, { TYPES_ToUInt64(720000000), TYPES_ToUInt64(800000000) } },

        { 5, CODERATE_1_2, BPSK, 270, 1, { TYPES_ToUInt64(67500000), TYPES_ToUInt64(75000000) } },
        { 5, CODERATE_1_2, QPSK, 540, 1, { TYPES_ToUInt64(135000000), TYPES_ToUInt64(150000000) } },
        { 5, CODERATE_3_4, QPSK, 810, 1, { TYPES_ToUInt64(202500000), TYPES_ToUInt64(225000000) } },
        { 5, CODERATE_1_2, QAM16, 1080, 1, { TYPES_ToUInt64(270000000), TYPES_ToUInt64(300000000) } },
        { 5, CODERATE_3_4, QAM16, 1620, 1, { TYPES_ToUInt64(405000000), TYPES_ToUInt64(450000000) } },
        { 5, CODERATE_2_3, QAM64, 2160, 1, { TYPES_ToUInt64(540000000), TYPES_ToUInt64(600000000) } },
        { 5, CODERATE_3_4, QAM64, 2430, 2, { TYPES_ToUInt64(607500000), TYPES_ToUInt64(675000000) } },
        { 5, CODERATE_5_6, QAM64, 2700, 2, { TYPES_ToUInt64(675000000), TYPES_ToUInt64(750000000) } },
        { 5, CODERATE_3_4, QAM256, 3240, 2, { TYPES_ToUInt64(810000000), TYPES_ToUInt64(900000000) } },
        { 5, CODERATE_5_6, QAM256, 3600, 2, { TYPES_ToUInt64(900000000), TYPES_ToUInt64(1000000000) } },

        { 6, CODERATE_1_2, BPSK, 324, 1, { TYPES_ToUInt64(81000000), TYPES_ToUInt64(90000000) } },
        { 6, CODERATE_1_2, QPSK, 648, 1, { TYPES_ToUInt64(162000000), TYPES_ToUInt64(180000000) } },
        { 6, CODERATE_3_4, QPSK, 972, 1, { TYPES_ToUInt64(243000000), TYPES_ToUInt64(270000000) } },
        { 6, CODERATE_1_2, QAM16, 1296, 1, { TYPES_ToUInt64(324000000), TYPES_ToUInt64(360000000) } },
        { 6, CODERATE_3_4, QAM16, 1944, 1, { TYPES_ToUInt64(486000000), TYPES_ToUInt64(540000000) } },
        { 6, CODERATE_2_3, QAM64, 2592, 2, { TYPES_ToUInt64(648000000), TYPES_ToUInt64(720000000) } },
        { 6, CODERATE_3_4, QAM64, 2916, 2, { TYPES_ToUInt64(729000000), TYPES_ToUInt64(810000000) } },
        { 6, CODERATE_5_6, QAM64, 3240, 2, { TYPES_ToUInt64(810000000), TYPES_ToUInt64(900000000) } },
        { 6, CODERATE_3_4, QAM256, 3888, 2, { TYPES_ToUInt64(972000000), TYPES_ToUInt64(1080000000) } },
        { 6, CODERATE_5_6, QAM256, 4320, 2, { TYPES_ToUInt64(1080000000), TYPES_ToUInt64(1200000000) } },

        { 7, CODERATE_1_2, BPSK, 378, 1, { TYPES_ToUInt64(94500000), TYPES_ToUInt64(105000000) } },
        { 7, CODERATE_1_2, QPSK, 756, 1, { TYPES_ToUInt64(189000000), TYPES_ToUInt64(210000000) } },
        { 7, CODERATE_3_4, QPSK, 1134, 1, { TYPES_ToUInt64(283500000), TYPES_ToUInt64(315000000) } },
        { 7, CODERATE_1_2, QAM16, 1512, 1, { TYPES_ToUInt64(378000000), TYPES_ToUInt64(420000000) } },
        { 7, CODERATE_3_4, QAM16, 2268, 2, { TYPES_ToUInt64(567000000), TYPES_ToUInt64(630000000) } },
        { 7, CODERATE_2_3, QAM64, 3024, 2, { TYPES_ToUInt64(756000000), TYPES_ToUInt64(840000000) } },
        { 7, CODERATE_3_4, QAM64, 3402, 2, { TYPES_ToUInt64(850500000), TYPES_ToUInt64(945000000) } },
        { 7, CODERATE_5_6, QAM64, 3780, 2, { TYPES_ToUInt64(945000000), TYPES_ToUInt64(1050000000) } },
        { 7, CODERATE_3_4, QAM256, 4536, 3, { TYPES_ToUInt64(1134000000), TYPES_ToUInt64(1260000000) } },
        { 7, CODERATE_5_6, QAM256, 5040, 3, { TYPES_ToUInt64(1260000000), TYPES_ToUInt64(1400000000) } },

        { 8, CODERATE_1_2, BPSK, 432, 1, { TYPES_ToUInt64(108000000), TYPES_ToUInt64(120000000) } },
        { 8, CODERATE_1_2, QPSK, 864, 1, { TYPES_ToUInt64(216000000), TYPES_ToUInt64(240000000) } },
        { 8, CODERATE_3_4, QPSK, 1296, 1, { TYPES_ToUInt64(324000000), TYPES_ToUInt64(360000000) } },
        { 8, CODERATE_1_2, QAM16, 1728, 1, { TYPES_ToUInt64(432000000), TYPES_ToUInt64(480000000) } },
        { 8, CODERATE_3_4, QAM16, 2592, 2, { TYPES_ToUInt64(648000000), TYPES_ToUInt64(720000000) } },
        { 8, CODERATE_2_3, QAM64, 3456, 2, { TYPES_ToUInt64(864000000), TYPES_ToUInt64(960000000) } },
        { 8, CODERATE_3_4, QAM64, 3888, 2, { TYPES_ToUInt64(972000000), TYPES_ToUInt64(1080000000) } },
        { 8, CODERATE_5_6, QAM64, 4320, 2, { TYPES_ToUInt64(1080000000), TYPES_ToUInt64(1200000000) } },
        { 8, CODERATE_3_4, QAM256, 5184, 3, { TYPES_ToUInt64(1296000000), TYPES_ToUInt64(1440000000) } },
        { 8, CODERATE_5_6, QAM256, 5760, 3, { TYPES_ToUInt64(1440000000), TYPES_ToUInt64(1600000000) } } },


        { { 1, CODERATE_1_2, BPSK, 117, 1, { TYPES_ToUInt64(29300000), TYPES_ToUInt64(32500000) } },
        { 1, CODERATE_1_2, QPSK, 234, 1, { TYPES_ToUInt64(58500000), TYPES_ToUInt64(65000000) } },
        { 1, CODERATE_3_4, QPSK, 351, 1, { TYPES_ToUInt64(87800000), TYPES_ToUInt64(97500000) } },
        { 1, CODERATE_1_2, QAM16, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 1, CODERATE_3_4, QAM16, 702, 1, { TYPES_ToUInt64(175500000), TYPES_ToUInt64(195000000) } },
        { 1, CODERATE_2_3, QAM64, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 1, CODERATE_3_4, QAM64, 1053, 1, { TYPES_ToUInt64(263300000), TYPES_ToUInt64(292500000) } },
        { 1, CODERATE_5_6, QAM64, 1170, 1, { TYPES_ToUInt64(292500000), TYPES_ToUInt64(325000000) } },
        { 1, CODERATE_3_4, QAM256, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 1, CODERATE_5_6, QAM256, 1560, 1, { TYPES_ToUInt64(390000000), TYPES_ToUInt64(433300000) } },

        { 2, CODERATE_1_2, BPSK, 234, 1, { TYPES_ToUInt64(58500000), TYPES_ToUInt64(65000000) } },
        { 2, CODERATE_1_2, QPSK, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 2, CODERATE_3_4, QPSK, 702, 1, { TYPES_ToUInt64(175500000), TYPES_ToUInt64(195000000) } },
        { 2, CODERATE_1_2, QAM16, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 2, CODERATE_3_4, QAM16, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 2, CODERATE_2_3, QAM64, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 2, CODERATE_3_4, QAM64, 2106, 1, { TYPES_ToUInt64(526500000), TYPES_ToUInt64(585000000) } },
        { 2, CODERATE_5_6, QAM64, 2340, 2, { TYPES_ToUInt64(585000000), TYPES_ToUInt64(650000000) } },
        { 2, CODERATE_3_4, QAM256, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 2, CODERATE_5_6, QAM256, 3120, 2, { TYPES_ToUInt64(780000000), TYPES_ToUInt64(866700000) } },


        { 3, CODERATE_1_2, BPSK, 351, 1, { TYPES_ToUInt64(87800000), TYPES_ToUInt64(97500000) } },
        { 3, CODERATE_1_2, QPSK, 702, 1, { TYPES_ToUInt64(175500000), TYPES_ToUInt64(195000000) } },
        { 3, CODERATE_3_4, QPSK, 1053, 1, { TYPES_ToUInt64(263300000), TYPES_ToUInt64(292500000) } },
        { 3, CODERATE_1_2, QAM16, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 3, CODERATE_3_4, QAM16, 2106, 1, { TYPES_ToUInt64(526500000), TYPES_ToUInt64(585000000) } },
        { 3, CODERATE_2_3, QAM64, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 3, CODERATE_2_3, QAM64, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 3, CODERATE_5_6, QAM64, 3510, 2, { TYPES_ToUInt64(877500000), TYPES_ToUInt64(975000000) } },
        { 3, CODERATE_3_4, QAM256, 4212, 2, { TYPES_ToUInt64(1053000000), TYPES_ToUInt64(1170000000) } },
        { 3, CODERATE_5_6, QAM256, 4680, 3, { TYPES_ToUInt64(1170000000), TYPES_ToUInt64(1300000000) } },

        { 4, CODERATE_1_2, BPSK, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 4, CODERATE_1_2, QPSK, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 4, CODERATE_3_4, QPSK, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 4, CODERATE_1_2, QAM16, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 4, CODERATE_3_4, QAM16, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 4, CODERATE_2_3, QAM64, 3744, 2, { TYPES_ToUInt64(936000000), TYPES_ToUInt64(1040000000) } },
        { 4, CODERATE_3_4, QAM64, 4212, 2, { TYPES_ToUInt64(1053000000), TYPES_ToUInt64(1170000000) } },
        { 4, CODERATE_5_6, QAM64, 4680, 3, { TYPES_ToUInt64(1170000000), TYPES_ToUInt64(1300000000) } },
        { 4, CODERATE_3_4, QAM256, 5616, 3, { TYPES_ToUInt64(1404000000), TYPES_ToUInt64(1560000000) } },
        { 4, CODERATE_5_6, QAM256, 6240, 3, { TYPES_ToUInt64(1560000000), TYPES_ToUInt64(1733300000) } },

        { 5, CODERATE_1_2, BPSK, 585, 1, { TYPES_ToUInt64(146300000), TYPES_ToUInt64(162500000) } },
        { 5, CODERATE_1_2, QPSK, 1170, 1, { TYPES_ToUInt64(292500000), TYPES_ToUInt64(325000000) } },
        { 5, CODERATE_3_4, QPSK, 1755, 1, { TYPES_ToUInt64(438800000), TYPES_ToUInt64(487500000) } },
        { 5, CODERATE_1_2, QAM16, 2340, 2, { TYPES_ToUInt64(585000000), TYPES_ToUInt64(650000000) } },
        { 5, CODERATE_3_4, QAM16, 3510, 2, { TYPES_ToUInt64(877500000), TYPES_ToUInt64(975000000) } },
        { 5, CODERATE_2_3, QAM64, 4680, 3, { TYPES_ToUInt64(1170000000), TYPES_ToUInt64(1300000000) } },
        { 5, CODERATE_3_4, QAM64, 5265, 3, { TYPES_ToUInt64(1316300000), TYPES_ToUInt64(1462500000) } },
        { 5, CODERATE_5_6, QAM64, 5850, 3, { TYPES_ToUInt64(1462500000), TYPES_ToUInt64(1625000000) } },
        { 5, CODERATE_3_4, QAM256, 7020, 4, { TYPES_ToUInt64(1755000000), TYPES_ToUInt64(1950000000) } },
        { 5, CODERATE_5_6, QAM256, 7800, 4, { TYPES_ToUInt64(1950000000), TYPES_ToUInt64(2166700000) } },

        { 6, CODERATE_1_2, BPSK, 702, 1, { TYPES_ToUInt64(175500000), TYPES_ToUInt64(195000000) } },
        { 6, CODERATE_1_2, QPSK, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 6, CODERATE_3_4, QPSK, 2106, 1, { TYPES_ToUInt64(526500000), TYPES_ToUInt64(585000000) } },
        { 6, CODERATE_1_2, QAM16, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 6, CODERATE_3_4, QAM16, 4212, 2, { TYPES_ToUInt64(1053000000), TYPES_ToUInt64(1170000000) } },
        { 6, CODERATE_2_3, QAM64, 5616, 3, { TYPES_ToUInt64(1404000000), TYPES_ToUInt64(1560000000) } },
        { 6, CODERATE_3_4, QAM64, 6318, 3, { TYPES_ToUInt64(1579500000), TYPES_ToUInt64(1755000000) } },
        { 6, CODERATE_5_6, QAM64, 7020, 4, { TYPES_ToUInt64(1755000000), TYPES_ToUInt64(1950000000) } },
        { 6, CODERATE_3_4, QAM256, 8424, 4, { TYPES_ToUInt64(2106000000), TYPES_ToUInt64(2340000000) } },
        { 6, CODERATE_3_4, QAM256, 8424, 4, { TYPES_ToUInt64(2106000000), TYPES_ToUInt64(2340000000) } },

        { 7, CODERATE_1_2, BPSK, 819, 1, { TYPES_ToUInt64(204800000), TYPES_ToUInt64(227500000) } },
        { 7, CODERATE_1_2, QPSK, 1638, 1, { TYPES_ToUInt64(409500000), TYPES_ToUInt64(455000000) } },
        { 7, CODERATE_3_4, QPSK, 2457, 3, { TYPES_ToUInt64(614300000), TYPES_ToUInt64(682500000) } },
        { 7, CODERATE_1_2, QAM16, 3276, 2, { TYPES_ToUInt64(819000000), TYPES_ToUInt64(910000000) } },
        { 7, CODERATE_3_4, QAM16, 4914, 3, { TYPES_ToUInt64(1228500000), TYPES_ToUInt64(1365000000) } },
        { 7, CODERATE_2_3, QAM64, 6552, 4, { TYPES_ToUInt64(1638000000), TYPES_ToUInt64(1820000000) } },
        { 7, CODERATE_2_3, QAM64, 6552, 4, { TYPES_ToUInt64(1638000000), TYPES_ToUInt64(1820000000) } },
        { 7, CODERATE_5_6, QAM64, 8190, 6, { TYPES_ToUInt64(2047500000), TYPES_ToUInt64(2275000000) } },
        { 7, CODERATE_3_4, QAM256, 9828, 6, { TYPES_ToUInt64(2457000000), TYPES_ToUInt64(2730000000) } },
        { 7, CODERATE_5_6, QAM256, 10920, 6, { TYPES_ToUInt64(2730000000), TYPES_ToUInt64(3033300000) } },

        { 8, CODERATE_1_2, BPSK, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 8, CODERATE_1_2, QPSK, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 8, CODERATE_3_4, QPSK, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 8, CODERATE_1_2, QAM16, 3744, 2, { TYPES_ToUInt64(936000000), TYPES_ToUInt64(1040000000) } },
        { 8, CODERATE_3_4, QAM16, 5616, 3, { TYPES_ToUInt64(1404000000), TYPES_ToUInt64(1560000000) } },
        { 8, CODERATE_2_3, QAM64, 7488, 4, { TYPES_ToUInt64(1872000000), TYPES_ToUInt64(2080000000) } },
        { 8, CODERATE_3_4, QAM64, 8424, 4, { TYPES_ToUInt64(2106000000), TYPES_ToUInt64(2340000000) } },
        { 8, CODERATE_5_6, QAM64, 9360, 6, { TYPES_ToUInt64(2340000000), TYPES_ToUInt64(2600000000) } },
        { 8, CODERATE_3_4, QAM256, 11232, 6, { TYPES_ToUInt64(2808000000), TYPES_ToUInt64(3120000000) } },
        { 8, CODERATE_5_6, QAM256, 12480, 6, { TYPES_ToUInt64(3120000000), TYPES_ToUInt64(3466700000) } } },


      { { 1, CODERATE_1_2, BPSK, 234, 1, { TYPES_ToUInt64(58500000), TYPES_ToUInt64(65000000) } },
        { 1, CODERATE_1_2, QPSK, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 1, CODERATE_3_4, QPSK, 702, 1, { TYPES_ToUInt64(175500000), TYPES_ToUInt64(195000000) } },
        { 1, CODERATE_1_2, QAM16, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 1, CODERATE_3_4, QAM16, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 1, CODERATE_2_3, QAM64, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 1, CODERATE_3_4, QAM64, 2106, 1, { TYPES_ToUInt64(526500000), TYPES_ToUInt64(585000000) } },
        { 1, CODERATE_5_6, QAM64, 2340, 2, { TYPES_ToUInt64(585000000), TYPES_ToUInt64(650000000) } },
        { 1, CODERATE_3_4, QAM256, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 1, CODERATE_5_6, QAM256, 3120, 2, { TYPES_ToUInt64(780000000), TYPES_ToUInt64(866700000) } },

        { 2, CODERATE_1_2, BPSK, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 2, CODERATE_1_2, QPSK, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 2, CODERATE_3_4, QPSK, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 2, CODERATE_1_2, QAM16, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 2, CODERATE_3_4, QAM16, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 2, CODERATE_2_3, QAM64, 3744, 2, { TYPES_ToUInt64(936000000), TYPES_ToUInt64(1040000000) } },
        { 2, CODERATE_3_4, QAM64, 4212, 2, { TYPES_ToUInt64(1053000000), TYPES_ToUInt64(1170000000) } },
        { 2, CODERATE_5_6, QAM64, 4680, 3, { TYPES_ToUInt64(1170000000), TYPES_ToUInt64(1300000000) } },
        { 2, CODERATE_3_4, QAM256, 5616, 3, { TYPES_ToUInt64(1404000000), TYPES_ToUInt64(1560000000) } },
        { 2, CODERATE_5_6, QAM256, 6240, 3, { TYPES_ToUInt64(1560000000), TYPES_ToUInt64(1733300000) } },

        { 3, CODERATE_1_2, BPSK, 702, 1, { TYPES_ToUInt64(175500000), TYPES_ToUInt64(195000000) } },
        { 3, CODERATE_1_2, QPSK, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 3, CODERATE_3_4, QPSK, 2106, 1, { TYPES_ToUInt64(526500000), TYPES_ToUInt64(585000000) } },
        { 3, CODERATE_1_2, QAM16, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 3, CODERATE_3_4, QAM16, 4212, 2, { TYPES_ToUInt64(1053000000), TYPES_ToUInt64(1170000000) } },
        { 3, CODERATE_2_3, QAM64, 5616, 3, { TYPES_ToUInt64(1404000000), TYPES_ToUInt64(1560000000) } },
        { 3, CODERATE_3_4, QAM64, 6318, 3, { TYPES_ToUInt64(1579500000), TYPES_ToUInt64(1755000000) } },
        { 3, CODERATE_5_6, QAM64, 7020, 4, { TYPES_ToUInt64(1755000000), TYPES_ToUInt64(1950000000) } },
        { 3, CODERATE_3_4, QAM256, 8424, 4, { TYPES_ToUInt64(2106000000), TYPES_ToUInt64(2340000000) } },
        { 3, CODERATE_3_4, QAM256, 8424, 4, { TYPES_ToUInt64(2106000000), TYPES_ToUInt64(2340000000) } },

        { 4, CODERATE_1_2, BPSK, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 4, CODERATE_1_2, QPSK, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 4, CODERATE_3_4, QPSK, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 4, CODERATE_1_2, QAM16, 3744, 2, { TYPES_ToUInt64(936000000), TYPES_ToUInt64(1040000000) } },
        { 4, CODERATE_3_4, QAM16, 5616, 3, { TYPES_ToUInt64(1404000000), TYPES_ToUInt64(1560000000) } },
        { 4, CODERATE_2_3, QAM64, 7488, 4, { TYPES_ToUInt64(1872000000), TYPES_ToUInt64(2080000000) } },
        { 4, CODERATE_3_4, QAM64, 8424, 4, { TYPES_ToUInt64(2106000000), TYPES_ToUInt64(2340000000) } },
        { 4, CODERATE_5_6, QAM64, 9360, 6, { TYPES_ToUInt64(2340000000), TYPES_ToUInt64(2600000000) } },
        { 4, CODERATE_3_4, QAM256, 11232, 6, { TYPES_ToUInt64(2808000000), TYPES_ToUInt64(3120000000) } },
        { 4, CODERATE_5_6, QAM256, 12480, 6, { TYPES_ToUInt64(3120000000), TYPES_ToUInt64(3466700000) } },

        { 5, CODERATE_1_2, BPSK, 1170, 1, { TYPES_ToUInt64(292500000), TYPES_ToUInt64(325000000) } },
        { 5, CODERATE_1_2, QPSK, 2340, 2, { TYPES_ToUInt64(585000000), TYPES_ToUInt64(650000000) } },
        { 5, CODERATE_3_4, QPSK, 3510, 2, { TYPES_ToUInt64(877500000), TYPES_ToUInt64(975000000) } },
        { 5, CODERATE_1_2, QAM16, 4680, 3, { TYPES_ToUInt64(1170000000), TYPES_ToUInt64(1300000000) } },
        { 5, CODERATE_3_4, QAM16, 7020, 4, { TYPES_ToUInt64(1755000000), TYPES_ToUInt64(1950000000) } },
        { 5, CODERATE_2_3, QAM64, 9360, 5, { TYPES_ToUInt64(2340000000), TYPES_ToUInt64(2600000000) } },
        { 5, CODERATE_3_4, QAM64, 10530, 5, { TYPES_ToUInt64(2632500000), TYPES_ToUInt64(2925000000) } },
        { 5, CODERATE_5_6, QAM64, 11700, 6, { TYPES_ToUInt64(2925000000), TYPES_ToUInt64(3250000000) } },
        { 5, CODERATE_3_4, QAM256, 14040, 8, { TYPES_ToUInt64(3510000000), TYPES_ToUInt64(3900000000) } },
        { 5, CODERATE_5_6, QAM256, 15600, 8, { TYPES_ToUInt64(3900000000), TYPES_ToUInt64(4333300000) } },

        { 6, CODERATE_1_2, BPSK, 1404, 1, { TYPES_ToUInt64(351000000), TYPES_ToUInt64(390000000) } },
        { 6, CODERATE_1_2, QPSK, 2808, 2, { TYPES_ToUInt64(702000000), TYPES_ToUInt64(780000000) } },
        { 6, CODERATE_3_4, QPSK, 4212, 2, { TYPES_ToUInt64(1053000000), TYPES_ToUInt64(1170000000) } },
        { 6, CODERATE_1_2, QAM16, 5616, 3, { TYPES_ToUInt64(1404000000), TYPES_ToUInt64(1560000000) } },
        { 6, CODERATE_3_4, QAM16, 8424, 4, { TYPES_ToUInt64(2106000000), TYPES_ToUInt64(2340000000) } },
        { 6, CODERATE_2_3, QAM64, 11232, 6, { TYPES_ToUInt64(2808000000), TYPES_ToUInt64(3120000000) } },
        { 6, CODERATE_3_4, QAM64, 12636, 6, { TYPES_ToUInt64(3159000000), TYPES_ToUInt64(3510000000) } },
        { 6, CODERATE_5_6, QAM64, 14040, 8, { TYPES_ToUInt64(3510000000), TYPES_ToUInt64(3900000000) } },
        { 6, CODERATE_3_4, QAM256, 16848, 8, { TYPES_ToUInt64(4212000000), TYPES_ToUInt64(4680000000) } },
        { 6, CODERATE_5_6, QAM256, 18720, 9, { TYPES_ToUInt64(4680000000), TYPES_ToUInt64(5200000000) } },

        { 7, CODERATE_1_2, BPSK, 1638, 1, { TYPES_ToUInt64(409500000), TYPES_ToUInt64(455000000) } },
        { 7, CODERATE_1_2, QPSK, 3276, 2, { TYPES_ToUInt64(819000000), TYPES_ToUInt64(910000000) } },
        { 7, CODERATE_3_4, QPSK, 4914, 3, { TYPES_ToUInt64(1228500000), TYPES_ToUInt64(1365000000) } },
        { 7, CODERATE_1_2, QAM16, 6552, 4, { TYPES_ToUInt64(1638000000), TYPES_ToUInt64(1820000000) } },
        { 7, CODERATE_3_4, QAM16, 9828, 6, { TYPES_ToUInt64(2457000000), TYPES_ToUInt64(2730000000) } },
        { 7, CODERATE_2_3, QAM64, 13104, 7, { TYPES_ToUInt64(3276000000), TYPES_ToUInt64(3640000000) } },
        { 7, CODERATE_3_4, QAM64, 14742, 7, { TYPES_ToUInt64(3685500000), TYPES_ToUInt64(4095000000) } },
        { 7, CODERATE_5_6, QAM64, 16380, 9, { TYPES_ToUInt64(4095000000), TYPES_ToUInt64(4550000000) } },
        { 7, CODERATE_3_4, QAM256, 19656, 12, { TYPES_ToUInt64(4914000000), TYPES_ToUInt64(5460000000) } },
        { 7, CODERATE_5_6, QAM256, 21840, 12, { TYPES_ToUInt64(5460000000), TYPES_ToUInt64(6066700000) } },

        { 8, CODERATE_1_2, BPSK, 1872, 1, { TYPES_ToUInt64(468000000), TYPES_ToUInt64(520000000) } },
        { 8, CODERATE_1_2, QPSK, 3744, 2, { TYPES_ToUInt64(936000000), TYPES_ToUInt64(1040000000) } },
        { 8, CODERATE_3_4, QPSK, 5616, 3, { TYPES_ToUInt64(1404000000), TYPES_ToUInt64(1560000000) } },
        { 8, CODERATE_1_2, QAM16, 7488, 4, { TYPES_ToUInt64(1872000000), TYPES_ToUInt64(2080000000) } },
        { 8, CODERATE_3_4, QAM16, 11232, 6, { TYPES_ToUInt64(2808000000), TYPES_ToUInt64(3120000000) } },
        { 8, CODERATE_2_3, QAM64, 14976, 8, { TYPES_ToUInt64(3744000000), TYPES_ToUInt64(4160000000) } },
        { 8, CODERATE_3_4, QAM64, 16848, 8, { TYPES_ToUInt64(4212000000), TYPES_ToUInt64(4680000000) } },
        { 8, CODERATE_5_6, QAM64, 18720, 9, { TYPES_ToUInt64(4680000000), TYPES_ToUInt64(5200000000) } },
        { 8, CODERATE_3_4, QAM256, 22464, 12, { TYPES_ToUInt64(5616000000), TYPES_ToUInt64(6240000000) } },
        { 8, CODERATE_5_6, QAM256, 24960, 12, { TYPES_ToUInt64(6240000000), TYPES_ToUInt64(6933300000) } }
    } };

const Phy802_11ac::MCSParam
  Phy802_11ac::MCS_Params_N[NUM_CH_BW_802_11N][32] =
    { { { 1, CODERATE_1_2, BPSK, 26, 1, { TYPES_ToUInt64(6500000), TYPES_ToUInt64(7200000) } },
        { 1, CODERATE_1_2, QPSK, 52, 1, { TYPES_ToUInt64(13000000), TYPES_ToUInt64(14400000) } },
        { 1, CODERATE_3_4, QPSK, 78, 1, { TYPES_ToUInt64(19500000), TYPES_ToUInt64(21700000) } },
        { 1, CODERATE_1_2, QAM16, 104, 1, { TYPES_ToUInt64(26000000), TYPES_ToUInt64(28900000) } },
        { 1, CODERATE_3_4, QAM16, 156, 1, { TYPES_ToUInt64(39000000), TYPES_ToUInt64(43300000) } },
        { 1, CODERATE_2_3, QAM64, 208, 1, { TYPES_ToUInt64(52000000), TYPES_ToUInt64(57800000) } },
        { 1, CODERATE_3_4, QAM64, 234, 1, { TYPES_ToUInt64(58500000), TYPES_ToUInt64(65000000) } },
        { 1, CODERATE_5_6, QAM64, 260, 1, { TYPES_ToUInt64(65000000), TYPES_ToUInt64(72200000) } },
        

        { 2, CODERATE_1_2, BPSK, 52, 1, { TYPES_ToUInt64(13000000), TYPES_ToUInt64(14400000) } },
        { 2, CODERATE_1_2, QPSK, 104, 1, { TYPES_ToUInt64(26000000), TYPES_ToUInt64(28900000) } },
        { 2, CODERATE_3_4, QPSK, 156, 1, { TYPES_ToUInt64(39000000), TYPES_ToUInt64(43300000) } },
        { 2, CODERATE_1_2, QAM16, 208, 1, { TYPES_ToUInt64(52000000), TYPES_ToUInt64(57800000) } },
        { 2, CODERATE_3_4, QAM16, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },
        { 2, CODERATE_2_3, QAM64, 416, 1, { TYPES_ToUInt64(104000000), TYPES_ToUInt64(115600000) } },
        { 2, CODERATE_3_4, QAM64, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 2, CODERATE_5_6, QAM64, 520, 1, { TYPES_ToUInt64(130000000), TYPES_ToUInt64(144400000) } },
        

        { 3, CODERATE_1_2, BPSK, 78, 1, { TYPES_ToUInt64(19500000), TYPES_ToUInt64(21700000) } },
        { 3, CODERATE_1_2, QPSK, 156, 1, { TYPES_ToUInt64(39000000), TYPES_ToUInt64(43300000) } },
        { 3, CODERATE_3_4, QPSK, 234, 1, { TYPES_ToUInt64(58500000), TYPES_ToUInt64(65000000) } },
        { 3, CODERATE_1_2, QAM16, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },
        { 3, CODERATE_3_4, QAM16, 468, 1, { TYPES_ToUInt64(117000000), TYPES_ToUInt64(130000000) } },
        { 3, CODERATE_2_3, QAM64, 624, 1, { TYPES_ToUInt64(156000000), TYPES_ToUInt64(173300000) } },
        { 3, CODERATE_3_4, QAM64, 702, 1, { TYPES_ToUInt64(175500000), TYPES_ToUInt64(195000000) } },
        { 3, CODERATE_5_6, QAM64, 780, 1, { TYPES_ToUInt64(195000000), TYPES_ToUInt64(216700000) } },
        

        { 4, CODERATE_1_2, BPSK, 104, 1, { TYPES_ToUInt64(26000000), TYPES_ToUInt64(28900000) } },
        { 4, CODERATE_1_2, QPSK, 208, 1, { TYPES_ToUInt64(52000000), TYPES_ToUInt64(57800000) } },
        { 4, CODERATE_3_4, QPSK, 312, 1, { TYPES_ToUInt64(78000000), TYPES_ToUInt64(86700000) } },
        { 4, CODERATE_1_2, QAM16, 416, 1, { TYPES_ToUInt64(104000000), TYPES_ToUInt64(115600000) } },
        { 4, CODERATE_3_4, QAM16, 624, 1, { TYPES_ToUInt64(156000000), TYPES_ToUInt64(173300000) } },
        { 4, CODERATE_2_3, QAM64, 832, 1, { TYPES_ToUInt64(208000000), TYPES_ToUInt64(231100000) } },
        { 4, CODERATE_3_4, QAM64, 936, 1, { TYPES_ToUInt64(234000000), TYPES_ToUInt64(260000000) } },
        { 4, CODERATE_5_6, QAM64, 1040, 1, { TYPES_ToUInt64(260000000), TYPES_ToUInt64(288900000) } } },
     
      { { 1, CODERATE_1_2, BPSK, 54, 1, { TYPES_ToUInt64(13500000), TYPES_ToUInt64(15000000) } },
        { 1, CODERATE_1_2, QPSK, 108, 1, { TYPES_ToUInt64(27000000), TYPES_ToUInt64(30000000) } },
        { 1, CODERATE_3_4, QPSK, 162, 1, { TYPES_ToUInt64(40500000), TYPES_ToUInt64(45000000) } },
        { 1, CODERATE_1_2, QAM16, 216, 1, { TYPES_ToUInt64(54000000), TYPES_ToUInt64(60000000) } },
        { 1, CODERATE_3_4, QAM16, 324, 1, { TYPES_ToUInt64(81000000), TYPES_ToUInt64(90000000) } },
        { 1, CODERATE_2_3, QAM64, 432, 1, { TYPES_ToUInt64(108000000), TYPES_ToUInt64(120000000) } },
        { 1, CODERATE_3_4, QAM64, 486, 1, { TYPES_ToUInt64(121500000), TYPES_ToUInt64(135000000) } },
        { 1, CODERATE_5_6, QAM64, 540, 1, { TYPES_ToUInt64(135000000), TYPES_ToUInt64(150000000) } },

        { 2, CODERATE_1_2, BPSK, 108, 1, { TYPES_ToUInt64(27000000), TYPES_ToUInt64(30000000) } },
        { 2, CODERATE_1_2, QPSK, 216, 1, { TYPES_ToUInt64(54000000), TYPES_ToUInt64(60000000) } },
        { 2, CODERATE_3_4, QPSK, 324, 1, { TYPES_ToUInt64(81000000), TYPES_ToUInt64(90000000) } },
        { 2, CODERATE_1_2, QAM16, 432, 1, { TYPES_ToUInt64(108000000), TYPES_ToUInt64(120000000) } },
        { 2, CODERATE_3_4, QAM16, 648, 1, { TYPES_ToUInt64(162000000), TYPES_ToUInt64(180000000) } },
        { 2, CODERATE_2_3, QAM64, 864, 1, { TYPES_ToUInt64(216000000), TYPES_ToUInt64(240000000) } },
        { 2, CODERATE_3_4, QAM64, 972, 1, { TYPES_ToUInt64(243000000), TYPES_ToUInt64(270000000) } },
        { 2, CODERATE_5_6, QAM64, 1080, 1, { TYPES_ToUInt64(270000000), TYPES_ToUInt64(300000000) } },

        { 3, CODERATE_1_2, BPSK, 162, 1, { TYPES_ToUInt64(40500000), TYPES_ToUInt64(45000000) } },
        { 3, CODERATE_1_2, QPSK, 324, 1, { TYPES_ToUInt64(81000000), TYPES_ToUInt64(90000000) } },
        { 3, CODERATE_3_4, QPSK, 486, 1, { TYPES_ToUInt64(121500000), TYPES_ToUInt64(135000000) } },
        { 3, CODERATE_1_2, QAM16, 648, 1, { TYPES_ToUInt64(162000000), TYPES_ToUInt64(180000000) } },
        { 3, CODERATE_3_4, QAM16, 972, 1, { TYPES_ToUInt64(243000000), TYPES_ToUInt64(270000000) } },
        { 3, CODERATE_2_3, QAM64, 1296, 1, { TYPES_ToUInt64(324000000), TYPES_ToUInt64(360000000) } },
        { 3, CODERATE_3_4, QAM64, 1458, 1, { TYPES_ToUInt64(364500000), TYPES_ToUInt64(405000000) } },
        { 3, CODERATE_5_6, QAM64, 1620, 1, { TYPES_ToUInt64(405000000), TYPES_ToUInt64(450000000) } },

        { 4, CODERATE_1_2, BPSK, 216, 1, { TYPES_ToUInt64(54000000), TYPES_ToUInt64(60000000) } },
        { 4, CODERATE_1_2, QPSK, 432, 1, { TYPES_ToUInt64(108000000), TYPES_ToUInt64(120000000) } },
        { 4, CODERATE_3_4, QPSK, 648, 1, { TYPES_ToUInt64(162000000), TYPES_ToUInt64(180000000) } },
        { 4, CODERATE_1_2, QAM16, 864, 1, { TYPES_ToUInt64(216000000), TYPES_ToUInt64(240000000) } },
        { 4, CODERATE_3_4, QAM16, 1296, 1, { TYPES_ToUInt64(324000000), TYPES_ToUInt64(360000000) } },
        { 4, CODERATE_2_3, QAM64, 1728, 1, { TYPES_ToUInt64(432000000), TYPES_ToUInt64(480000000) } },
        { 4, CODERATE_3_4, QAM64, 1944, 1, { TYPES_ToUInt64(486000000), TYPES_ToUInt64(540000000) } },
        { 4, CODERATE_5_6, QAM64, 2160, 1, { TYPES_ToUInt64(540000000), TYPES_ToUInt64(600000000) } } } };


/// \brief Handles signal arrival event
///
/// This function decides to lock the signal or not based on spectral band,
/// phy mode, rssi etc.Phy carrier sensing is also done.
///
/// \param node_ptr     Pointer to node
/// \param phyIndex     Phy index
/// \param channelIndex Channel Index
/// \param propRxInfo   Propagation Rx Info
void Phy802_11ac::signalArrival(Node* node_ptr,
                       int phyIndex,
                       int channelIndex,
                       PropRxInfo *propRxInfo)
{
    PhyData802_11* phy802_11 = m_parentData;
    Message* msg = propRxInfo->txMsg;

    Node& node = *node_ptr;
    const spectralBand* band = node.getRadioBand(phyIndex);
    double ni_dBm = node.sl().ni(propRxInfo, band, phyIndex);
    double s_dBm = node.sl().s(propRxInfo, phyIndex);

    Phy802_11PlcpHeader* plcp
        = (Phy802_11PlcpHeader*)MESSAGE_ReturnPacket(propRxInfo->txMsg);
    if (plcp->txPhyModel == PHY802_11a || plcp->txPhyModel == PHY802_11b)
    {
        //ERROR_ReportError("Interoperability with 802.11a/b is not supported");
    }

    switch (phy802_11->mode) {
        case PHY_RECEIVING:
        {
            PHY_NotificationOfPacketDrop(
                node_ptr,
                phyIndex,
                channelIndex,
                propRxInfo->txMsg,
                "PHY Busy in Receiving",
                pow(10.0, s_dBm/10.0),
                pow(10.0, ni_dBm/10.0),
                propRxInfo->pathloss_dB);
            break;
        }

        case PHY_IDLE:
        case PHY_SENSING:
        {
            Phy802_11PlcpHeader* plcp
              = (Phy802_11PlcpHeader*)MESSAGE_ReturnPacket(propRxInfo->txMsg);
            BOOL isDupMsg
                = plcp->nonHTMod == NON_HT_DUP_OFDM? TRUE:FALSE;
            spectralBand* msb = MESSAGE_GetSpectralBand(msg);
            ChBandwidth mchBwdth = getChBwdth(msb->getBandwidth());
            BOOL process = FALSE;
            if (isDupMsg)
            {
                spectralBand* cf= cc()->getSBand(CHBWDTH_20MHZ);
                if (cf->overlaps(*msb)
                    && plcp->format != MODE_HT_GF
                    && propRxInfo->txMsg->m_mimoData->m_elementCount
                        <= getNumActiveAtnaElems())
                {
                    // 11ac PHY.
                    // Process only those signals which are received on the
                    // band this PHY is tuned to.
                    // As per RFC, 11ac device doesn't support HT_GF format
                    process = TRUE;
                }
            }
            else
            {
                if (mchBwdth <= getOperationChBwdth())
                {
                    spectralBand* tsb = cc()->getSBand(mchBwdth);
                    if (tsb
                        && tsb->getFrequency() == msb->getFrequency()
                        && plcp->format != MODE_HT_GF
                        && propRxInfo->txMsg->m_mimoData->m_elementCount
                            <= getNumActiveAtnaElems())
                    {
                        process = TRUE;
                    }
                }
            }
            if (!process)
            {
                // can not receive message frequency mismatch
                PHY_NotificationOfPacketDrop(node_ptr,
                                    phyIndex,
                                    channelIndex,
                                    propRxInfo->txMsg,
                                    "Signal below Rx Threshold",
                                    pow(10.0, s_dBm/10.0),
                                    pow(10.0, ni_dBm/10.0),
                                    propRxInfo->pathloss_dB);

                PhyStatusType newMode;

                if (carrierSensing(FALSE, phyIndex))
                {
                    newMode = PHY_SENSING;
                }
                else
                {
                    newMode = PHY_IDLE;
                }

                if (newMode != phy802_11->mode)
                {
                    Phy802_11ChangeState(node_ptr, phyIndex, newMode);
                    Phy802_11ReportStatusToMac(node_ptr, phyIndex, newMode);
                }

                return;
            }

            double rxSensitivity_dBm(0.0);

            if (!isDupMsg)
            {
                rxSensitivity_dBm = getMinSensitivity_dBm(mchBwdth);
            }
            else
            {
                rxSensitivity_dBm = getMinSensitivity_dBm(CHBWDTH_20MHZ);
            }

            if (s_dBm >= rxSensitivity_dBm)
            {
                PropTxInfo *propTxInfo
                    = (PropTxInfo *)MESSAGE_ReturnInfo(propRxInfo->txMsg);

                clocktype txDuration = propTxInfo->duration;

                Phy802_11LockSignal(
                    node_ptr,
                    phy802_11,
                    propRxInfo,
                    propRxInfo->txMsg,
                    pow(10.0, s_dBm/10.0), // should be RSSI
                    (propRxInfo->rxStartTime + propRxInfo->duration),
                    channelIndex,
                    propRxInfo->txDOA,
                    propRxInfo->rxDOA);
#ifdef CYBER_LIB
                if (node.phyData[phyIndex]->jammerStatistics == TRUE)
                {
                    if (node.phyData[phyIndex]->jamInstances > 0)
                    {
                        phy802_11->stats.totalSignalsLockedDuringJam++;
                    }
                }
#endif

                Phy802_11ChangeState(node_ptr, phyIndex, PHY_RECEIVING);
                Phy802_11ReportExtendedStatusToMac(node_ptr,
                    phyIndex,
                    PHY_RECEIVING,
                    txDuration,
                    propRxInfo->txMsg);
            }
            else {
                // Otherwise, check if the signal changes the phy status
                PHY_NotificationOfPacketDrop(node_ptr,
                    phyIndex,
                    channelIndex,
                    propRxInfo->txMsg,
                    "Signal below Rx Threshold",
                    pow(10.0, s_dBm/10.0),
                    pow(10.0, ni_dBm/10.0),
                    propRxInfo->pathloss_dB);

                PhyStatusType newMode;

                if (carrierSensing(FALSE, phyIndex))
                {
                    newMode = PHY_SENSING;
                }
                else
                {
                    newMode = PHY_IDLE;
                }

                if (newMode != phy802_11->mode)
                {
                    Phy802_11ChangeState(node_ptr, phyIndex, newMode);

                    Phy802_11ReportStatusToMac(node_ptr,
                        phyIndex,
                        newMode);
                }
            }
            break;
        }
        default:
            ERROR_ReportError("Invalid PHY Mode");
            break;
    }
}

/// \brief Returns 802_11ac Frame duration
///
/// This function calculates and returns frame duration of 802_11ac frame
///
/// \param txParam Reference of transmission parameters of outgoing packet
///
/// \return Frame duration
clocktype Phy802_11ac::getFrameDuration(const MAC_PHY_TxRxVector& txParam)
{
    size_t dataBits;
    size_t numSymbols;
    clocktype frameDur = 0;
    clocktype symbolDur
        = (txParam.gi == GI_LONG ? 4000 * NANO_SECOND : 3600 * NANO_SECOND);

    ChBandwidth chBwdth = CHBWDTH_20MHZ;
    if (txParam.nonHTMod != NON_HT_DUP_OFDM)
    {
        chBwdth = txParam.chBwdth;
    }

/************** Interoperability feature *********START*******************/
    double dbps = 0;
    unsigned int numEs = 0;
    unsigned int numSts = 0;   //Number of spatial streams
    switch (txParam.phyType)
    {
    case k_Dot11a:
        dbps = phy802_11aNdbps[txParam.mcs];
        numEs = 1;
        break;
    case k_Dot11b:
        dbps = phy802_11bNdbps[txParam.mcs];
        numEs = 1;
        break;
    case k_Dot11n:
        dbps = MCS_Params_N[chBwdth - 1][txParam.mcs]
                                        .m_nDataBitsPerSymbol;
        numEs = MCS_Params_N[chBwdth - 1][txParam.mcs].m_numEs;
        numSts = MCS_Params_N[chBwdth - 1][txParam.mcs].m_nSpatialStream;
        break;
    case k_Dot11ac:
        dbps = MCS_Params[chBwdth - 1][txParam.mcs]
                                        .m_nDataBitsPerSymbol;
        numEs = MCS_Params[chBwdth - 1][txParam.mcs].m_numEs;
        numSts = MCS_Params[chBwdth - 1][txParam.mcs].m_nSpatialStream;
        break;
    }
/************** Interoperability feature *********END*******************/
    unsigned int mStbc = 1;
    switch (txParam.format)
    {
        case MODE_VHT:
        {
            assert(txParam.phyType == k_Dot11ac);
            dataBits = txParam.length*8
                       + Ppdu_Service_Bits_Size
                       + Ppdu_Tail_Bits_Size*numEs;
            numSymbols = mStbc * (size_t)ceil((double)dataBits /
                        (dbps*mStbc));
            if (txParam.gi == GI_LONG)
            {
                frameDur = preambDur_VHT(numSts)
                             + numSymbols * T_Sym;
            }
            else
            {
                frameDur = preambDur_VHT(numSts)
                + T_Sym * ((size_t)ceil((double)numSymbols * T_Syms/T_Sym));
            }
            break;
        }
        case MODE_HT_MF:
        {
            assert(txParam.phyType == k_Dot11ac || txParam.phyType == k_Dot11n);
            dataBits = txParam.length*8
                       + Ppdu_Service_Bits_Size
                       + Ppdu_Tail_Bits_Size*numEs;
            numSymbols = mStbc * (size_t)ceil((double)dataBits/
                           (dbps*mStbc));

            if (txParam.gi == GI_LONG) {
                frameDur = preambDur_HtMixed(numSts, txParam.numEss)
                             + numSymbols * T_Sym;
            }
            else
            {
                frameDur = preambDur_HtMixed(numSts, txParam.numEss)
                             + T_Sym * ((size_t)ceil(
                                        (double)numSymbols * T_Syms/T_Sym));
            }
            break;
        }
        case MODE_NON_HT:
        {
            if (txParam.phyType == k_Dot11a)
            {
                dataBits = txParam.length*8
                       + Ppdu_Service_Bits_Size
                       + Ppdu_Tail_Bits_Size;

                numSymbols = (size_t)ceil((double)dataBits/dbps);

                frameDur = PHY802_11a_SYNCHRONIZATION_TIME
                           + (numSymbols * PHY802_11a_OFDM_SYMBOL_DURATION)
                              * MICRO_SECOND;
            }

            else if (txParam.phyType == k_Dot11b)
            {
                dataBits = txParam.length*8;
                numSymbols = (size_t)ceil((double)dataBits/dbps);
                frameDur = PHY802_11b_SYNCHRONIZATION_TIME + numSymbols
                                                    * MICRO_SECOND;
            }
            else
            {
                dataBits = txParam.length*8
                       + Ppdu_Service_Bits_Size
                       + Ppdu_Tail_Bits_Size;
                numSymbols = (size_t)ceil((double)dataBits/dbps);
                frameDur = preambDur_NonHt() + (numSymbols * symbolDur);
            }
            break;
        }
        default:
            ERROR_ReportError("Invalid Tx Parameter Format");
            break;
    }

    char durStr[MAX_STRING_LENGTH];
    TIME_PrintClockInSecond(frameDur, durStr);
    DEBUG_PRINT("Phy802_11ac::GetFrameDuration: frame length(bytes): %"
        TYPES_SIZEOFMFT "d, "
        "frame MCS: %u, frame duration %s \n",
        txParam.length, txParam.mcs, durStr);
   return frameDur;
}

/// \brief Initializes Phy802_11 ac
///
/// This function initializes 802_11 ac by calling initialization
/// function for channel controller and reading configuration parameters
///
/// \param nodeInput Pointer to node input
void Phy802_11ac::init(const NodeInput* nodeInput)
{
    readCfgParams(nodeInput);
    readSensitivityParams(nodeInput);
}


void Phy802_11ac::readBwdthParams(const NodeInput* nodeInput)
{
    m_chController->readCfgParamsFor20MHz(nodeInput);
    m_chController->readCfgParamsFor40MHz(nodeInput);
    m_chController->readCfgParamsFor80MHz(nodeInput);
    m_chController->readCfgParamsFor160MHz(nodeInput);
    spectralBand* sp = m_chController->getSBand(
                m_chController->getConfChBwdth());
    m_node->setRadioBand(
                m_parentData->thisPhy->phyIndex, sp);
}


/// \brief Read 802_11ac sensitivity parameters
///
/// This function reads 802_11ac sensitivity parameters
/// from configuration file.
///
/// \param nodeInput Pointer to node input
void Phy802_11ac::readSensitivityParams(const NodeInput* nodeInput)
{
    Node* node = m_node;
    int phyIndex = m_parentData->thisPhy->phyIndex;

    const char* k_types[] = { "20MHz", "40MHz", "80MHz", "160MHz" };
    const ChBandwidth k_idxs[] = { CHBWDTH_20MHZ, CHBWDTH_40MHZ, CHBWDTH_80MHZ, CHBWDTH_160MHZ };

    for (int k1(0); k1 < 4; k1++)
    {
      const char* bw_str = k_types[k1];
      const ChBandwidth bw_idx = k_idxs[k1];

      for (int k2 = 0; k2 < MCS_NUMS_SINGLE_SS; k2++)
      {
        char buf[1024];
        (void)sprintf(buf, "PHY802.11-RX-SENSITIVITY-%s-MCS%d", bw_str, k2);

        BOOL wasFound(FALSE);
        double rxSensitivity_dBm = 0;

        IO_ReadDouble(node, node->nodeId,
                      node->phyData[phyIndex]->macInterfaceIndex,
                      nodeInput,
                      buf, 
                      &wasFound,
                      &rxSensitivity_dBm);

        if (wasFound) 
        {
          m_RxSensitivity_dBm[bw_idx - 1][k2] = rxSensitivity_dBm;
        }
      }
    }
}


/// \brief Handles the signal end event
///
/// This function handles signal end event, function decides whether to receive
/// message and pass it to MAC or not. Set phy state, update statistics.
///
/// \param node     Pointer to node
/// \param phyIndex Phy Index
/// \channelIndex   Channel Index
/// \propRxInfo     Pointer to propagation Rx info
void Phy802_11ac::signalEnd(Node* node,
                   int phyIndex,
                   int channelIndex,
                   PropRxInfo *propRxInfo)
{
    double sinr = -1.0;
    PhyData802_11* phy802_11 = m_parentData;

    ERROR_Assert(phy802_11->mode != PHY_TRANSMITTING,
                 "Phy should not be in transmitting model at signal end");

    spectralBand* msgBand = MESSAGE_GetSpectralBand(propRxInfo->txMsg);
    double s_dBm = node->sl().s(propRxInfo, phyIndex);
    double ni_dBm = node->sl().ni(propRxInfo, msgBand, phyIndex);
    double rssi_dBm = node->sl().rssi(msgBand, node->getNodeTime(), phyIndex);
    double noise_dBm = node->sl().n(phyIndex, msgBand);

    if ((phy802_11->mode == PHY_RECEIVING) && (phy802_11->rxMsg == propRxInfo->txMsg))
    {

#ifdef ADDON_DB
        Phy802_11UpdateEventsTable(node,
                                   phyIndex,
                                   channelIndex,
                                   propRxInfo,
                                   pow(10.0, s_dBm/10.0),
                                   phy802_11->rxMsg,
                                   "PhyReceiveSignal");
#endif

        Message* newMsg = NULL;

        node->setMIMO_Data(phyIndex, propRxInfo->txMsg->m_mimoData->m_elementCount,
            getAtnaElemSpace(), msgBand);

        BOOL inError = checkPacketError(&sinr, propRxInfo, phyIndex);

        int msgSize = 0;
        int overheadSize = 0;

        if (!phy802_11->rxMsg->isPacked)
        {
            msgSize = MESSAGE_ReturnPacketSize(phy802_11->rxMsg);
        }
        else
        {
            msgSize = MESSAGE_ReturnActualPacketSize(phy802_11->rxMsg);
        }

        MAC_PHY_TxRxVector rxVector;
        this->getRxVectorOfLockedSignal(rxVector);

/************** Interoperability feature *********START*******************/
        // Check for interoperability
        int numSts
            = MCS_Params[rxVector.chBwdth - 1][rxVector.mcs].m_nSpatialStream;
        clocktype dataRate =
           Phy802_11ac::MCS_Params[CHBWDTH_20MHZ - 1][0].m_dataRate[0];
        clocktype preamble = preambDur_VHT(numSts);
/************** Interoperability feature *********END*******************/

        overheadSize = (int)((preamble * dataRate) / SECOND
                       + Ppdu_Service_Bits_Size
                       + Ppdu_Tail_Bits_Size);
        overheadSize /= 8;

        phy802_11->sController->updateStat(
            "PhyReceived",
            msgSize,
            overheadSize,
            IN_DB(phy802_11->rxMsgPower_mW),
            sinr,
            rssi_dBm,
            ni_dBm,
            propRxInfo->pathloss_dB);


        Phy802_11UnlockSignal(phy802_11);

        if (carrierSensing(TRUE, phyIndex) == TRUE)
        {
            Phy802_11ChangeState(node,phyIndex, PHY_SENSING);
        }
        else
        {
            Phy802_11ChangeState(node,phyIndex, PHY_IDLE);
        }

        if (!inError)
        {
            //Perform Signal measurement
            PhySignalMeasurement sigMeasure;
            sigMeasure.rxBeginTime = propRxInfo->rxStartTime;
            sigMeasure.rss = s_dBm;
            sigMeasure.snr = IN_DB(NON_DB(s_dBm)/NON_DB(noise_dBm));
            sigMeasure.cinr = sinr;
            newMsg = MESSAGE_Duplicate(node, propRxInfo->txMsg);

            // Remove MIMO related information from the message
            if (newMsg->m_mimoData)
            {
                delete newMsg->m_mimoData;
                newMsg->m_mimoData = NULL;
            }
            MESSAGE_RemoveHeader(
                node, newMsg, sizeof(Phy802_11PlcpHeader), TRACE_802_11);

            MESSAGE_SetInstanceId(newMsg, (short) phyIndex);
            phy802_11->rxDOA = propRxInfo->rxDOA;

#ifdef ADDON_DB
            Phy802_11UpdateEventsTable(node,
                                       phyIndex,
                                       channelIndex,
                                       propRxInfo,
                                       pow(10.0, s_dBm/10.0),
                                       newMsg,
                                       "PhySendToUpper");
#endif
            PhySignalMeasurement* signalMeaInfo = NULL;
            MESSAGE_InfoAlloc(node,
                              newMsg,
                              sizeof(PhySignalMeasurement));
            signalMeaInfo = (PhySignalMeasurement*)
                            MESSAGE_ReturnInfo(newMsg);
            memcpy(signalMeaInfo,&sigMeasure,sizeof(PhySignalMeasurement));
            MAC_ReceivePacketFromPhy(node,
                node->phyData[phyIndex]->macInterfaceIndex,
                newMsg);

            PropTxInfo* txInfo = (PropTxInfo*) MESSAGE_ReturnInfo(
                                                 propRxInfo->txMsg);
            clocktype txDelay = propRxInfo->rxStartTime
                                - txInfo->txStartTime;

            if (phy802_11->thisPhy->phyStats)
            {
                phy802_11->thisPhy->stats->AddSignalToMacDataPoints(
                    node,
                    propRxInfo,
                    phy802_11->thisPhy,
                    channelIndex,
                    txDelay,
                    pow(10.0, ni_dBm/10.0),
                    propRxInfo->pathloss_dB,
                    pow(10.0, s_dBm/10.0));
            }

#ifdef CYBER_LIB
            if (node->phyData[phyIndex]->jammerStatistics == TRUE)
            {
                if (node->phyData[phyIndex]->jamInstances > 0)
                {
                    phy802_11->stats.totalRxSignalsToMacDuringJam++;
                }
            }
#endif
        }
        else
        {
            Phy802_11ReportStatusToMac(node, phyIndex, phy802_11->mode);

            PHY_NotificationOfPacketDrop(
                node,
                phyIndex,
                channelIndex,
                propRxInfo->txMsg,
                "Signal Received with Error",
                pow(10.0, s_dBm/10.0),
                pow(10.0, ni_dBm/10.0),
                propRxInfo->pathloss_dB);

            if (phy802_11->thisPhy->phyStats)
            {
                phy802_11->thisPhy->stats->AddSignalWithErrorsDataPoints(
                    node,
                    propRxInfo,
                    phy802_11->thisPhy,
                    channelIndex,
                    pow(10.0, ni_dBm/10.0),
                    pow(10.0, s_dBm/10.0));
            }

#ifdef CYBER_LIB
            if (node->phyData[phyIndex]->jammerStatistics == TRUE)
            {
                if (node->phyData[phyIndex]->jamInstances > 0)
                {
                    phy802_11->stats.totalSignalsWithErrorsDuringJam++;
                }
            }
#endif

        }//if//

        DEBUG_PRINT("Signal ends in receiving and it's the receiving signal,"
            "noise+interference power(dB): %lf \n", ni_dBm);
    }
    else {
        PhyStatusType newMode;

        if (phy802_11->mode != PHY_RECEIVING)
        {
           if (carrierSensing(TRUE, phyIndex) == TRUE)
           {
               newMode = PHY_SENSING;
           }
           else
           {
               newMode = PHY_IDLE;
           }

           if (newMode != phy802_11->mode)
           {
                Phy802_11ChangeState(node,phyIndex, newMode);
                Phy802_11ReportStatusToMac(
                   node,
                   phyIndex,
                   newMode);
           }
        }

        DEBUG_PRINT("Signal ends in other status,"
            "interference power(dBm): %lf \n", ni_dBm);
    }
}


/// \brief Calculates bit error rate
///
/// \param sinr Signal to noise ration
/// \param rxVector Rx vector
///
/// \return Bit Error rate
double Phy802_11ac::getBer(double sinr, const MAC_PHY_TxRxVector& rxVector)
{
    double ber = 0;
    double bandwidth = getBwdth_MHz(rxVector.chBwdth);
    double dataRate = getDataRate(rxVector);

    ber = PHY_MIMOBER(m_parentData->thisPhy, sinr, rxVector,
                      dataRate, bandwidth,
                      std::min(m_RxSignalInfo.m_txNumAtnaElmts, m_NumAtnaElmts),
                      m_RxSignalInfo.m_chnlEstMatrix,
                      getRxModel(rxVector));
    return ber;
}


/// \brief Returns Data rate based on txRxVector
///
/// This function returns data rate based on channel bandwidth mcs and
/// guard interval
///
/// \param txRxVector Tx RX vector
///
/// \return Data rate
double Phy802_11ac::getDataRate(const MAC_PHY_TxRxVector& txRxVector)
{
     return (double) (MCS_Params[txRxVector.chBwdth - 1][txRxVector.mcs]).m_dataRate[txRxVector.gi];
}

/// \brief Returns non Ht mode bandwidth
///
/// \param count
///
/// \return Channel Bandwidth
ChBandwidth Phy802_11ac::getNonHtBwdth(UInt8 count)
{
    ChBandwidth bwdth = CHBWDTH_20MHZ;

    if (count == 1)
    {
        bwdth = CHBWDTH_20MHZ;
    }
    else if (count < 4)
    {
        bwdth = CHBWDTH_40MHZ;
    }
    else if (count < 8)
    {
        bwdth = CHBWDTH_80MHZ;
    }
    else if (count == 8)
    {
        bwdth = CHBWDTH_160MHZ;
    }
    else
    {
        ERROR_ReportError("Wrong bandwidth count");
    }

    return bwdth;
}

/// \brief Check whether received packet has error or not.
///
/// \param propRxInfo Pointer to Propagation rx info
/// \param isDup      Is Dup message or not
/// \param isAmpdu    Is Ampdu or not
/// \param BER        Bit error rate
/// \dataRate         Data rate
///
/// \return True if packet has error, false otherwise
BOOL Phy802_11ac::inError(PropRxInfo* propRxInfo, BOOL isDup,
        double isAmpdu, double BER, double dataRate)
{
    BOOL inError = FALSE;
    if (BER != 0.0)
    {
        double numBits = 0;

        if (!isAmpdu)
        {
            numBits = ((propRxInfo->duration) * dataRate/(double)SECOND);
        }
        else
        {
            ERROR_Assert(!isDup, "Invalid frame");
            numBits = sizeof(Phy802_11PlcpHeader) * 8;
        }

        double errorProbability = 1.0 - pow((1.0 - BER), numBits);
        double rand = RANDOM_erand(m_parentData->thisPhy->seed);

        ERROR_Assert((errorProbability >= 0.0) && (errorProbability <= 1.0),
            "Error Probability should be b/w 0-1");

        if (errorProbability >= rand)
        {
            inError = TRUE;
        }
    }

    return inError;
}

/// \brief checks whether the packet is received with error or not
///
/// \param sinrPtr Pointer to signal to noise ration
/// \param propRxInfo Propagation rx info
/// \param phyIndex Phy index
///
/// \return True if packet is received with error, False other wise
BOOL Phy802_11ac::checkPacketError(double *sinrPtr, PropRxInfo* propRxInfo, int phyIndex)
{
    Phy802_11PlcpHeader* plcp
        = (Phy802_11PlcpHeader*)MESSAGE_ReturnPacket(propRxInfo->txMsg);

    Message* msg = propRxInfo->txMsg;
    BOOL isDupMsg = plcp->nonHTMod == NON_HT_DUP_OFDM? TRUE:FALSE;

    spectralBand* msb = MESSAGE_GetSpectralBand(msg); 
    ChBandwidth mchBwdth = getChBwdth(msb->getBandwidth());

    MIMO_Matrix_t lambda_k = MIMO_Matrix_t::Zero(
        propRxInfo->txMsg->m_mimoData->m_elementCount,
        propRxInfo->txMsg->m_mimoData->m_elementCount);
    m_node->MIMO_getEigenValues(propRxInfo, phyIndex,
            propRxInfo->txDOA, propRxInfo->rxDOA, lambda_k);

    if (isDupMsg)
    {
        *sinrPtr = -1;
        UInt8 count = 0;
        std::vector<SubChannel*> list = cc()->getSubChList();

        std::vector<SubChannel*>::iterator itr = list.begin();
        for (; itr != list.end(); itr++)
        {
            Int32 chIdx = (*itr)->getChIndex();
            spectralBand* sb = spectralBand_Square::make_80211ac20(
                                    chIdx,
                                    node()->partitionData,
                                    cc()->getRadioOverlayId());

            if (sb->overlaps(*msb))
            {
                double branch_snr_dB = node()->sl().snr(propRxInfo, sb, phyIndex);
                int ntx = propRxInfo->txMsg->m_mimoData->m_elementCount;

                // The sender sends data to his neighbor based on neighbor's
                // capability. If sender sends with ntx antenna elements. Receiver
                // could have num antennas (nrx) either more or equal to sender
                // antenna elements (nrx >= ntx).
                ERROR_AssertArgs(ntx <= getNumActiveAtnaElems(),
                    "Incorrect antenna configuration");
                int nrx = ntx;

                MIMO::Demapper demapper(ntx, nrx, branch_snr_dB, lambda_k, true);
                for (int k(0); k < lambda_k.size(); k++)
                {
                  demapper(k, MIMO::Stbc::Uncoded());
                }

                double mimo_snr_dB = demapper();
                double sinr = pow(10, mimo_snr_dB / 10.0);

                if (DEBUG)
                {
                    std::cout << "nodeId: " << node()->nodeId
                      << " branch_snr(dB): " << branch_snr_dB
                      << " lr:";

                    double se(0.0);
                    for (int k(0); k < lambda_k.size(); k++)
                    {
                       double lr = std::real(lambda_k(k));
                       se += lr;
                       std::cout << " " << lr;
                    }

                    int fn = ntx * nrx;

                    std::cout << " se: " << se << " fn: " << fn
                      << " calc snr(dB): " << mimo_snr_dB 
                      << std::endl;
                }

                MAC_PHY_TxRxVector rxVector = m_RxSignalInfo.m_rxVector;
                rxVector.chBwdth = CHBWDTH_20MHZ;
                double dataRate = getDataRate(rxVector);
                double ber = getBer(sinr, rxVector);

                if (inError(propRxInfo, TRUE, FALSE, ber, dataRate))
                {
                    break;
                }

                count++;
            }
            else
            {
                break;
            }
        }

        if (count == 0)
        {
            return TRUE;
        }

        m_PrevRxVector.chBwdthNonHt = getNonHtBwdth(count);

        return FALSE;
    }
    else
    {
        spectralBand* tsb = cc()->getSBand(mchBwdth);

        double branch_snr_dB = node()->sl().snr(propRxInfo, tsb, phyIndex);
        int ntx = propRxInfo->txMsg->m_mimoData->m_elementCount;

        // The sender sends data to his neighbor based on neighbor's
        // capability. If sender sends with ntx antenna elements. Receiver
        // could have num antennas (nrx) either more or equal to sender
        // antenna elements (nrx >= ntx).
        ERROR_AssertArgs(ntx <= getNumActiveAtnaElems(),
            "Incorrect antenna configuration");
        int nrx = ntx;

        MIMO::Demapper demapper(ntx, nrx, branch_snr_dB, lambda_k, true);
        for (int k(0); k < ntx; k++)
        {
          demapper(k, MIMO::Stbc::Uncoded());
        }

        double mimo_snr_dB = demapper();
        double sinr = pow(10, mimo_snr_dB / 10.0);

        if (DEBUG)
        {
          std::cout << "nodeId: " << node()->nodeId
            << " branch_snr(dB): " << branch_snr_dB
            << " lr:";

          double se(0.0);
          for (int k(0); k < lambda_k.size(); k++)
          { 
             double lr = std::real(lambda_k(k));
             se += lr;
             std::cout << " " << lr;
          }

          int fn = ntx * nrx;
          
          std::cout << " se: " << se << " fn: " << fn
            << " calc snr(dB): " << mimo_snr_dB << std::endl;
        }

        *sinrPtr = sinr;

        BOOL containAMPDU = FALSE;
        double ber = getBer(sinr, m_RxSignalInfo.m_rxVector);
        double dataRate = getDataRate(m_RxSignalInfo.m_rxVector);

        if (plcp->containAMPDU)
        {
            containAMPDU = TRUE;

            void* info_ptr = (void*)MESSAGE_AddInfo(node(),
                m_parentData->rxMsg, sizeof(double), INFO_TYPE_Dot11nBER);

            memcpy(info_ptr, (void*)&ber, sizeof(double));
        }

        return inError(propRxInfo, FALSE, containAMPDU, ber, dataRate);
    }
}

/// \brief Checks whether the phy is able to sense signal or not
///
/// Function compares receive signal strength with min rx sensitivity
/// at 20Mhz and takes decision accordingly.
///
/// \param isSigEnd Whether this is signal end or not
/// \param phyIndex Phy Index
///
/// \return TRUE if RSSI is more than or equal to sensitivity
///         FALSE otherwise
BOOL Phy802_11ac::carrierSensing(BOOL isSigEnd, int phyIndex)
{
    double rxSensitivity_dBm = getMinSensitivity_dBm(CHBWDTH_20MHZ);
    spectralBand* sb = cc()->getSBand(CHBWDTH_20MHZ);

    clocktype now = node()->getNodeTime();

    double rssi_dBm = node()->sl().rssi(sb, now, phyIndex);

    if (DEBUG)
    {
        std::cout << "CarrierSensing rssi(dBm): " << rssi_dBm << " position: "
          << (isSigEnd ? "EOP" : "SOP") << std::endl;
    }

    if (rssi_dBm >= rxSensitivity_dBm)
    {
        return TRUE;
    }

    return FALSE;
}

/// \brief Function for clear channel assessment
///
/// Function checks whether the band is idle if not then
/// checks for next idle band
///
/// \param chBwdth Channel bandwidth
///
/// \return Channel bandwidth of free channel
ChBandwidth Phy802_11ac::cca(ChBandwidth chBwdth)
{
    ChBandwidth avlChBwdth = CHBWDTH_20MHZ;
    double rssi_dBm = 0;
    Int32 i = (Int32)CHBWDTH_20MHZ;
    int radioOverlayId = cc()->getRadioOverlayId();
    while (i < (Int32)chBwdth)
    {
        Int32 idx = cc()->getSChIndex((ChBandwidth)i);
        spectralBand* sb;
        if (i+1 == (Int32)CHBWDTH_40MHZ)
        {
            sb = spectralBand_Square::make_80211ac20(idx,
                                       node()->partitionData,
                                       radioOverlayId);
        }
        else if (i+1 == (Int32)CHBWDTH_80MHZ)
        {
            sb = spectralBand_Square::make_80211ac40(idx,
                                        node()->partitionData,
                                        radioOverlayId);
        }
        else
        {
            sb = spectralBand_Square::make_80211ac80(idx,
                                         node()->partitionData,
                                         radioOverlayId);
        }
        rssi_dBm = node()->sl().rssi(sb, node()->getNodeTime(), ifIdx());
        ERROR_Assert(i <= 3, "Invalid channel bandwidth in CCA request");
        if (rssi_dBm >= energyT_dBm(i))
        {
            avlChBwdth = (ChBandwidth)i;
            break;
        }
        else
        {
            avlChBwdth = (ChBandwidth)(i+1);
            i++;
        }
    }
    return avlChBwdth;
 }

/// \brief Checks if the signal can be processed
///
/// \param phyIndex Index of this phy
/// \param propRxInfo Pointer to Propagation rx info
/// \param rxPower_dBm Signal power in dBm
///
/// \return True if signal can be processed. False otherwise.
BOOL Phy802_11ac::processSignal(int phyIndex,
                       PropRxInfo* propRxInfo,
                       double rxPower_dBm)
{
    PhyData802_11* phy802_11 = m_parentData;
    Message* msg = propRxInfo->txMsg;

    Node& node = *m_node;
    spectralBand* msb = MESSAGE_GetSpectralBand(msg);

    Phy802_11PlcpHeader* plcp
                  = (Phy802_11PlcpHeader*)MESSAGE_ReturnPacket(propRxInfo->txMsg);
    BOOL isDupMsg = plcp->nonHTMod == NON_HT_DUP_OFDM? TRUE:FALSE;
    ChBandwidth mchBwdth = getChBwdth(msb->getBandwidth());
    BOOL process = FALSE;
    if (isDupMsg)
    {
        spectralBand* cf= cc()->getSBand(CHBWDTH_20MHZ);
        if (cf->overlaps(*msb))
        {
            process = TRUE;
        }
    }
    else
    {
        if (mchBwdth <= getOperationChBwdth())
        {
            spectralBand* tsb = cc()->getSBand(mchBwdth);
            if (tsb->getFrequency() == msb->getFrequency())
            {
                process = TRUE;
            }
        }
    }
    return process;
}

/// \brief Calculates the control overhead
///
/// \return Control overhead
int Phy802_11ac::getControlOverhead()
{
    int overheadSize = 0;
    MAC_PHY_TxRxVector rxVector;
    getRxVectorOfLockedSignal(rxVector);
    int numSts
        = MCS_Params[rxVector.chBwdth - 1][rxVector.mcs].m_nSpatialStream;
    clocktype dataRate =
        Phy802_11ac::MCS_Params[CHBWDTH_20MHZ - 1][0].m_dataRate[0];
    clocktype preamble = preambDur_VHT(numSts);
    overheadSize = (int)((preamble * dataRate) / SECOND
                    + Ppdu_Service_Bits_Size
                    + Ppdu_Tail_Bits_Size);
    overheadSize /= 8;
    return overheadSize;
}
